# Блок 3

## Условие задания

> ### Спецификация
> 
> **Вам нужно создать новые эндпоинты `API`, позволяющие пользователю выполнять следующие действия:**
> - Создавать новых собак, отправляя `POST-запрос на `/api/dogs/`.
> - Получать список всех сохраненных собак, отправляя `GET`-запрос на `/api/dogs/`.
> - Получать, модифицировать или удалять существующую запись о собаке, отправляя `GET`, `PUT` или `DELETE`-запрос
> соответственно на `/api/dogs/<id>`, где `<id>` - это идентификатор записи о собаке.
>
> Поскольку у собаки есть внешний ключ на породу, вам также нужно создать аналогичные конечные точки для пород собак
> по адресам `/api/breeds/` и `/api/breeds/<id>`.
>
> **Модель Dog**
> Собака должна содержать следующие поля:
> - `name` (строка символов)
> - `age` (целое число)
> - `breed` (внешний ключ к модели Breed)
> - `gender` (строка символов)
> - `color` (строка символов)
> - `favorite_food` (строка символов)
> - `favorite_toy` (строка символов)
> 
> **Модель Breed**
> Порода должна содержать следующие поля:
> - `name` (строка символов)
> - `size` (строка символов) [должно принимать значения Tiny, Small, Medium, Large]
> - `friendliness` (поле целого числа) [должно принимать значения от 1 до 5]
> - `train_ability` (поле целого числа) [должно принимать значения от 1 до 5]
> - `shedding_amount` (поле целого числа) [должно принимать значения от 1 до 5]
> - `exercise_needs` (поле целого числа) [должно принимать значения от 1 до 5]
>
> Тщательно протестируйте ваши эндпоинты `API` `Dog` и `Breed`.
> Для модели `Dog`:
> - `GET` (список) на `/api/dogs/` - должен включать информацию о среднем возрасте собак каждой породы.
> - `POST` на `/api/dogs/`
> - `GET` на `/api/dogs/<id>` - должен включать количество собак той же породы.
> - `PUT` на `/api/dogs/<id>`
> - `DELETE` на `/api/dogs/<id>`
> Для модели `Breed`:
> - `GET` (список) на `/api/breeds/` - должен включать количество собак каждой породы.
> - `POST` на `/api/breeds/`
> - `GET` на `/api/breeds/<id>`
> - `PUT` на `/api/breeds/<id>`
> - `DELETE` на `/api/breeds/<id>`
>
> [!NOTE]
> При выполнении этих запросов убедитесь, что реализованы подзапросы или использование `OuterRef` для получения связанной
> информации без повторного обращения к базе данных. Это особенно важно для следующих случаев:
> - При получении списка собак (`/api/dogs/`) должна быть включена информация о среднем возрасте собак данной породы.
> - При получении информации о конкретной собаке (`/api/dogs/<id>`) должно быть указано количество собак той же породы.
> - При получении списка пород (`/api/breeds/`) должно быть указано количество собак каждой породы.
> 
> ### Требования к реализации
> 1. **Структура проекта**
> - Проект должен быть структурирован в соответствии с лучшими практиками Django.
> - Все необходимые файлы должны быть размещены в соответствующих директориях.
> 2. **Модели**
> - Создать модели `Dog` и `Breed` в файле `models.py`.
> - Модели должны соответствовать спецификации, указанной в задании.
> - Использовать подходящие типы полей `Django ORM`.
> 3. **API ViewSets**
> - Реализовать классы `DogViewSet` и `BreedViewSet` в файле `views.py`.
> - Каждый `ViewSet` должен содержать методы для обработки `GET`, `POST`, `PUT` и `DELETE` запросов.
> - Использовать `Django Rest Framework` для создания `API`.
> 4. **URL конфигурация**
> - Создать файл `urls.py` с правильной маршрутизацией для всех конечных точек `API`.
> - Использовать роутеры `DRF` для автоматической генерации `URL-паттернов`.
> 5. **Документация кода**
> - Все классы, функции и методы должны быть документированы с помощью `docstrings`.
> - `Docstrings` должны соответствовать стандарту `Google Python Style Guide`.
> - Описывать параметры, возвращаемые значения и возможные исключения.
> 6. **Стиль кода**
> - Соблюдать `PEP-8` стиль кодирования.
> - Максимальная длина строки не должна превышать 119 символов.
> - Использовать линтер и/или форматтер (например, `flake8` или `ruff`) для проверки соблюдения стилевых правил.
> 7. **`Docker` контейнеризация**
> - Создать `Dockerfile` для сборки образа приложения.
> - Написать `docker-compose.yml` файл для управления сервисами (`Django` и `PostgreSQL`).
> - Убедиться, что приложение корректно работает внутри `Docker-контейнера`.
> 8. **Подзапросы и оптимизация**
> - Реализовать требуемые подзапросы или использование `OuterRef` для получения дополнительной информации:
> - Средний возраст собак данной породы при получении списка собак.
> - Количество собак той же породы при получении информации о конкретной собаке.
> - Количество собак каждой породы при получении списка пород.
> 9. **Версионирование**
> - Использовать систему контроля версий `Git`.
> - Создавать отдельную ветку для разработки (например, `feature/dog-api`).
> - Делать коммиты регулярно с осмысленными сообщениями.
> 10. **Зависимости**
> - Использовать `requirements.txt` для управления зависимостями проекта.
> - Указывать версии используемых библиотек.
> 11. **Настройки окружения**
> - Использовать .env файл для хранения конфиденциальных данных и переменных окружения.
> - Создать пример файла .env.example с описанием необходимых переменных.
> 12. **`README.md`**
> - Создать `README.md` файл с инструкцией по установке и запуску проекта.
> - Описать основные компоненты проекта и его архитектуру.
> - Предоставить примеры использования API.

## Принцип реализации

В проекте используется архитектурный подход `DDD`, который не является типичным для `Django` приложений. 
Автор решил не использовать стандартный `Django` подход в виде `MVT` паттерна, так как она является плохо масштабируемой.
Если придется проект переписывать с `Django` на условный `litestar`, то придется переписывать всю кодовую базу. 

> [!NOTE]
> - [MVT Pattern Django](https://parikshapatr.com/solutions/django-model-view-template-architectural-pattern)
> - [DDD](https://stackoverflow.com/questions/5325836/what-is-domain-driven-design) 

## Зависимости

- [`poetry`](https://python-poetry.org/)
- [`django`](https://www.djangoproject.com/)
- [`django-ninja`](https://django-ninja.dev/)
- [`mypy`](https://www.mypy-lang.org/)
- [`ruff`](https://docs.astral.sh/ruff/)
- [`isort`](https://pycqa.github.io/isort/)
- [`anydi`](https://pyxdi.readthedocs.io/en/latest/usage/)
- [`django-stubs`](https://github.com/typeddjango/django-stubs)

> [!MOTE]
> Полезные ссылки, которые могут вам пригодится с ознакомлением 
> https://github.com/vitalik/django-ninja/issues/1155
> https://youtu.be/XqkqbsdtoMI?si=22GhDHKp7VuyTEWO
> https://django-ninja.dev/tutorial/other/crud/

## Структура проекта

Сама логика проекта находится в директории `sitedogs`. 
В данном проекте находится только 1 Django приложение, которое называется `dogs`. 
По условию задачи все было связано только с собаками, поэтому назвал так проект.
Внутри данного проекта есть 6 директорий, которые могут Вас заинтересовать. 

- `application`
- `domain`
- `exceptions`
- `logic`
- `migrations`

> [!IMPORTANT]
> С какой целью был так назван проект?
> Проект посвящен собакам, а `Django` проекты имеют название, как будущий домен. 

Рассмотрим каждый модуль по отдельности. Поймем за что он нужен, за что он отвечает.

### Что такое `domain`? 

В основе `DDD` - Домен (Domain). Это модель предмета и его задач, под которые строится приложение. Счет, который оплачиваем, Сообщение, которое отправляем, или Пользователь, которому выставляем оценку. Домены строятся на сущностях из реального мира и ложатся в центр приложения. 

> [!NOTE]
> Например, по заданию у нас библиотека, где нужно оперировать книгами, поэтому `domain` - это книга. 
> Если добавится сервис регистрации, то появится новый `domain` - это человек.

### Что там находится внутри директории `domain`?

Там Вы найдете 2 директории, которые Вас должны заинтересовать `entities` и `values`. 

- [`entities`](https://blog.jannikwempe.com/domain-driven-design-entities-value-objects) - это и есть наши домены, про которые я говорил выше. Пример домена собаки можете увидеть [здесь](sitedogs/dogs/domain/entities/dogs.py)
- [`values`](https://blog.jannikwempe.com/domain-driven-design-entities-value-objects) - здесь находятся, так называемые, `value objects`. Грубо говоря, это характеристики нашего домена, т.е поля (атрибуты) `domain`. Почему делается так? Все очень просто: для валидации данных. Пример `value objects` для собаки [здесь](sitedogs/dogs/domain/values/dog.py)

> [!NOTE]
> Если Вы хотите добавить новый `domain`, то создайте `Python` файл, который описывает его. Например, `peoples.py`. Ваш класс должен наследоваться от [`BaseEntity`](sitedogs/core/domain/entities/base.py). Пример прилагаю ниже: 

```python
@dataclass(eq=False)
class Human:
  """
  Domain which associated with the real human
  """
  nickname: NickName
  email: Email
  is_active: bool
```

> [!NOTE]
> Если Вы хотите добавить новый `value object`, то создайте `Python` файл, который описывает его. Например, `surname.py`. Ваш класс должен наследоваться от [`BaseValueObject`](sitedogs/core/domain/values/base.py). Пример прилагаю ниже:

```python
@dataclass(frozen=True)
class NickName(BaseValueObject[str]):
    """
    Value object which associated with the book name
    """
    value: str

    @override
    def validate(self) -> None:
        if not self.value:
            raise EmptyTextException()

        if len(self.value) > 15:
            raise ValueTooLongException(self.value)

    @override
    def as_generic_type(self) -> str:
        return self.value
```

### Что такое `application`?

Здесь обычно содержится `api` для работы с приложением. Различные [backend endpoints](https://dev.to/apidna/api-endpoints-a-beginners-guide-ief), [sockets](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)) и т.п. 
Каждая директория в `api` - это `handlers` для сущности (домен), с которой мы работаем.

> [!NOTE]
> Например, по заданию у нас написать `API` для собак, где нужно оперировать собаками, поэтому директория называется `dogs`. 
> Если бы нужно было добавить функционал для работы с пользователем, то в `application/api` появилась бы директория `people`.

### Что за файлы в `application/api/{domain}`?

- `handlers.py` - здесь находится та часть, которая выступает "мордой" нашего приложения. Здесь на данном слое работает `Django Ninja`. 
- `schemas.py` - здесь находятся схемы валидации данных или просто [`DTO`](https://ru.wikipedia.org/wiki/DTO). 
Здесь используется валидация от Django Ninja, который основан на [`pydantic BaseModel`](https://docs.pydantic.dev/latest/api/base_model/) для валидации данных. 
Пример для собак [`schemas.py`](sitedogs/dogs/application/api/v1/dogs/schemas.py)

## Что такое `infrastrucutre`?

На данном слое архитектуры реализована логика работы с данными посредством следующих паттернов:

- [`Repository`](https://www.cosmicpython.com/book/chapter_02_repository.html), 
- [`Service`](https://lyz-code.github.io/blue-book/architecture/service_layer_pattern/)

> [!IMPORTANT]
> В `Django` нет возможности контролировать транзакции, поэтому слоя с `Unit of Work` нет. 
> Репозитории напрямую инжектирую в контейнере, используя `anydi`. 

### Что там находится внутри директории `infrastrucutre`?

Здесь вы найдете директории и `Python` файлы для описания работ. Каждая директория также называется, как и паттерн, которые я указал выше. Давайте рассмотрим каждый из них по отдельности.  

#### `Repository`

Здесь реализована логика работы с базой данных на уровне объектов. Репозиторий управляет коллекцией доменов (моделей).
В случае данного тестового задания написано несколько имплементаций:

- [Породами](sitedogs/dogs/infrastructure/repositories/breeds/django_orm.py)
- [Собаками](sitedogs/dogs/infrastructure/repositories/dogs/django_orm.py).

Как можно написать свой репозиторий? Все очень просто: Вам нужно унаследоваться от интерфейса, который описывает ваш домен.
Пример интерфейса для репозитория управления собаками можете увидеть [здесь](sitedogs/dogs/infrastructure/repositories/dogs/base.py).

> [!IMPORTANT]
> Может возникнуть вопрос. А как правильно конвертировать из `Entity` в `Django Model`.
> Для этого случая автор использовал [паттерн адаптер](https://refactoring.guru/ru/design-patterns/adapter).
> Пример моей реализации можете увидеть [здесь](sitedogs/dogs/infrastructure/adapters/django_orm/dogs.py)

### Что такое `logic`?

Здесь на данном слое собрана вся бизнес логика, где требуется реализовать наш функционал по тз. 
В `logic` у нас есть директории `commands` и `use cases`.

#### `Commands`

Команды - это действие, которое должно выполнять наше приложение. Например, создать пользователя, создать собаку, удалить собаку.
Обычно это оформляется в виде `DTO` класса. Примеры вот [здесь](sitedogs/dogs/logic/commands/dogs.py).
Но если команды это `DTO`, то как осуществлять бизнес логику? Здесь на помощь приходят `handlers`, которые вы можете увидеть ниже.
Пока приведу пример того, как написать свою команды для регистрации условного человека в нашей библиотеке. 

```python
@dataclass(frozen=True)
class RegisterHumanCommand(AbstractCommand):
    username: str
    password: str
    email: str
```

#### `Use Cases`

Это как раз перехватчики наших команд, которые уже работают с сервисами. 

```python
class RegisterUserUseCase:
    def __init__(self, repository: UserRepository):
        self._service = UserService(repository)
    
    def execute(self, command: RegisterUserCommand):
        human: HumanEntity = HumanEntity(**command.to_dict())
        
        if self._service.check_existence(human.oid):
            raise HumanExistsError(human.oid)
        
        return self._service.add(Human)
```

Но встает вопрос. Как это все связать, чтобы все заработало? Все это происходит из-за преждевременной настройки в контейнере. 
Возникает вопрос, а как добавить мой юзкейс? Для этого зайдите в [контейнер](sitedogs/dogs/logic/container.py) и добавьте нужный метод. 

### `exceptions`

Судя из названия понятно, что здесь находятся ошибки приложения. 

### `migrations`

Файлы миграций, который Django сам создает. Команды все те же, настройка была произведена на правильные модели. 

## Как запустить проект с `docker`? 

Для этого используется `Makefile`, из-под которого можно запускать различные команды. 
Если у Вас установлен `make`, то введите просто команду

```bash
make all
```

> [!IMPORTANT]
> Управлять системой make в проекте можно, находясь на самом верхнем уровне проекта. 
> Грубо говоря, изначальный путь, когда вы открыли проект в редакторе кода / IDE. 

## Документация Swagger

![изображение](https://github.com/user-attachments/assets/09497d4f-b7b2-4873-8e91-55e7dfce92dd)


